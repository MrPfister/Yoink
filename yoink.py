import sys
from inspect import isclass, getmembers
from typing import Callable, List, Dict, Any, Optional, Tuple
from importlib import import_module
from functools import wraps
import warnings
import logging
from inspect import signature
from types import FrameType, ModuleType, TracebackType, FunctionType

_logger = logging.getLogger(__name__)
_logger.setLevel = logging.DEBUG

classes_searched = set()

SENSITIVE_PARAMS = set(["pass", "password", "uname", "username", "timeout"])
SENSITIVE_FUNC_NAMES = set(["auth", "login"])


def get_fully_qualified_name(obj: Any) -> str:
    """Returns the fully qualified name of a function or class

    Args:
        obj (Any): Class or Function object

    Returns:
        str: Fully qualified name
    """
    module = f"{obj.__module__}." if hasattr(obj, "__module__") else ""

    if module == "builtins.":
        return obj.__qualname__  # Edge case for int, str etc.

    if isclass(obj):
        return f"{module}{obj.__qualname__}"
    else:
        return f"{module}{obj.__class__.__qualname__}"


def _log_decorator(*args, **kwargs) -> Tuple[Any, Any]:
    _logger.info(f"Args: {','.join(args)}")
    _logger.info(f"Kwargs: {','.join(kwargs)}")
    return (args, kwargs)


def _attach_extraction_decorator(
    wrapped_func: Callable, wrapper: Optional[Callable]
) -> Callable:
    """Wraps a function to enable param extraction"""

    # Use .wraps to bypass any security checks, but populates func.__wrapped__
    @wraps(wrapped_func)
    def _func_decorator(*args, **kwargs) -> Any:
        if wrapper:
            # If we want to perform additional manipulation of the data
            wrapper(args=args, kwargs=kwargs)

        return wrapped_func(*args, **kwargs)

    return _func_decorator


def _get_package_func_listing(module: ModuleType) -> Dict[str, Any]:
    listing = {}
    for n, obj in getmembers(module):
        if callable(obj):
            # Even if the object is callable, doesn't mean it allows for introspection
            if hasattr(obj, "__code__"):
                listing[n] = obj
        elif isclass(obj) and obj not in classes_searched:
            classes_searched.add(obj)
            listing.update(_get_package_func_listing(obj))

    return listing


def _contains_sensitive_param(func: FunctionType) -> bool:
    if not hasattr(func.__code__, "co_varnames"):
        return False

    params = [p.lower() for p in signature(func).parameters.keys()]

    # For ease of use, convert all to lower case
    return len(SENSITIVE_PARAMS.intersection(set(params))) > 0


def _is_sensitive_func(func: FunctionType) -> bool:
    return func.__name__.lower() in SENSITIVE_FUNC_NAMES


def yoink() -> None:
    """Paginates through the loaded modules and attaches a decorator to functions that expose security information"""

    # Force all warnings generated by compliance to be shown
    warnings.simplefilter("always")

    funcs = {}
    for m in sys.modules:
        funcs.update(_get_package_func_listing(sys.modules[m]))

    for f in funcs:
        if _is_sensitive_func(funcs[f]):
            funcs[f] = _attach_extraction_decorator(funcs[f], None)
        elif _contains_sensitive_param(funcs[f]):
            funcs[f] = _attach_extraction_decorator(funcs[f], None)


if __name__ == "__main__":
    # Hook onto any sensitive functions exposed within attached modules.
    yoink()
